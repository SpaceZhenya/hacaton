<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8"/>
  <title>3D Shooter — Охрана патрулирует базу</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #crosshair {
      position: absolute; top: 50%; left: 50%;
      width: 20px; height: 20px;
      margin: -10px 0 0 -10px;
      pointer-events: none;
      background: url('data:image/svg+xml;utf8,\
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20">\
          <circle cx="10" cy="10" r="2" fill="white"/>\
        </svg>'
      ) no-repeat center;
    }
    #kills {
      position: absolute; top: 10px; left: 10px;
      color: white; font-size: 18px; text-shadow: 0 0 5px black;
    }
  </style>
</head>
<body>
  <div id="crosshair"></div>
  <div id="kills">Убито: 0</div>

  <script src="https://unpkg.com/three@0.153.0/build/three.min.js"></script>
  <script>
    // Базовые переменные
    let scene, camera, renderer;
    const player = new THREE.Group();
    const bullets = [];
    const targets = [];
    const guards = [];
    let kills = 0;
    const clock = new THREE.Clock();
    const move = { forward: 0, turn: 0 };
    const speed = 8, turnSpeed = 2.5;

    // Для стрельбы по клику
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    const groundPlane = new THREE.Plane(new THREE.Vector3(0,1,0), 0);

    init();
    animate();

    function init() {
      // Сцена и рендер
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x20232a);
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Камера
      camera = new THREE.PerspectiveCamera(
        75, window.innerWidth/window.innerHeight, 0.1, 1000
      );

      // Свет и пол
      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(5,10,7.5);
      scene.add(light);
      const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(200,200),
        new THREE.MeshStandardMaterial({ color: 0x808080 })
      );
      floor.rotation.x = -Math.PI/2;
      scene.add(floor);

      // Игрок
      createLowPolyHuman(player, 0x00aa00);
      scene.add(player);
      player.position.set(0,0,0);

      // Окружение
      createBase();
      createTargets();
      createGuards();

      // Управление
      setupControls();
      window.addEventListener('resize', onResize);
    }

    // Рисуем low-poly человечка в заданную группу
    function createLowPolyHuman(group, color) {
      const mat = new THREE.MeshStandardMaterial({ color });
      const torso = new THREE.Mesh(new THREE.BoxGeometry(0.5,1,0.3), mat);
      torso.position.y = 1; group.add(torso);
      const head = new THREE.Mesh(new THREE.BoxGeometry(0.3,0.3,0.3), mat.clone());
      head.position.y = 1.6; group.add(head);
      const armGeo = new THREE.BoxGeometry(0.15,0.7,0.15);
      const leftArm = new THREE.Mesh(armGeo, mat);
      const rightArm = leftArm.clone();
      leftArm.position.set(-0.35,1.15,0); rightArm.position.set(0.35,1.15,0);
      group.add(leftArm, rightArm);
      const legGeo = new THREE.BoxGeometry(0.2,0.8,0.2);
      const leftLeg = new THREE.Mesh(legGeo, mat);
      const rightLeg = leftLeg.clone();
      leftLeg.position.set(-0.15,0.4,0); rightLeg.position.set(0.15,0.4,0);
      group.add(leftLeg, rightLeg);
    }

    // База
    function createBase() {
      const wallMat   = new THREE.MeshStandardMaterial({ color: 0x444444 });
      const buildMat  = new THREE.MeshStandardMaterial({ color: 0x666666 });
      const detailMat = new THREE.MeshStandardMaterial({ color: 0x555555 });

      // Стены
      const wallV = new THREE.BoxGeometry(1,4,60);
      const wallH = new THREE.BoxGeometry(60,4,1);
      [[-30,0],[30,0]].forEach(([x,z])=>{
        const w = new THREE.Mesh(wallV, wallMat);
        w.position.set(x,2,z); scene.add(w);
      });
      [[0,-30],[0,30]].forEach(([x,z])=>{
        const w = new THREE.Mesh(wallH, wallMat);
        w.position.set(x,2,z); scene.add(w);
      });

      // Вышки
      const towerGeo = new THREE.CylinderGeometry(1.5,1.5,12,8);
      for (let dx of [-28,28]) for (let dz of [-28,28]) {
        const tower = new THREE.Mesh(towerGeo, buildMat);
        tower.position.set(dx,6,dz); scene.add(tower);
        const top = new THREE.Mesh(
          new THREE.CylinderGeometry(2,2,0.5,12), detailMat
        );
        top.position.set(dx,12.25,dz); scene.add(top);
      }

      // Корпуса и коридор
      const b1 = new THREE.Mesh(new THREE.BoxGeometry(16,4,6), buildMat);
      b1.position.set(-8,2,-10); scene.add(b1);
      const b2 = new THREE.Mesh(new THREE.BoxGeometry(6,4,16), buildMat);
      b2.position.set(10,2,8); scene.add(b2);
      const cor = new THREE.Mesh(new THREE.BoxGeometry(4,3,10), wallMat);
      cor.position.set(1,1.5,-2); scene.add(cor);

      // Ворота
      const gateMat = new THREE.MeshStandardMaterial({ color: 0x888888 });
      const g1 = new THREE.Mesh(new THREE.BoxGeometry(6,3,0.5), gateMat);
      const g2 = g1.clone();
      g1.position.set(-3,1.5,30); g2.position.set(3,1.5,30);
      scene.add(g1, g2);

      // Хелипад
      const pad = new THREE.Mesh(
        new THREE.CircleGeometry(5,32),
        new THREE.MeshStandardMaterial({ color: 0x333333 })
      );
      pad.rotation.x = -Math.PI/2; pad.position.set(0,0.01,15);
      scene.add(pad);

      // Ящики и бочки
      for (let i=0; i<15; i++){
        const box = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), detailMat);
        box.position.set((Math.random()-0.5)*40,0.5,(Math.random()-0.5)*40);
        scene.add(box);
        if (i % 5 === 0) {
          const barrel = new THREE.Mesh(
            new THREE.CylinderGeometry(0.5,0.5,1.2,12),
            new THREE.MeshStandardMaterial({ color: 0x222222 })
          );
          barrel.position.set(
            (Math.random()-0.5)*40,0.6,(Math.random()-0.5)*40
          );
          scene.add(barrel);
        }
      }
    }

    // Цели
    function createTargets() {
      const geo = new THREE.BoxGeometry(1,1,1);
      const mat = new THREE.MeshStandardMaterial({ color: 0xff3333 });
      for (let i=0; i<20; i++){
        const t = new THREE.Mesh(geo, mat);
        t.position.set((Math.random()-0.5)*50,0.5,-Math.random()*50);
        scene.add(t); targets.push(t);
      }
    }

    // Охранники-патрули
    function createGuards() {
      const patrolPoints = [
        [ -20, 0, 20 ],
        [  20, 0, 20 ],
        [  20, 0,-20 ],
        [ -20, 0,-20 ]
      ];
      const guardSpeed = 2.5;

      for (let i=0; i<4; i++){
        const gGroup = new THREE.Group();
        createLowPolyHuman(gGroup, 0xffaa00);
        const wp = patrolPoints.map(p=>new THREE.Vector3(...p));
        gGroup.position.copy(wp[i]);
        scene.add(gGroup);
        guards.push({
          mesh: gGroup,
          waypoints: wp,
          idx: i,
          speed: guardSpeed
        });
      }
    }

    // Контролы и стрельба
    function setupControls() {
      document.addEventListener('keydown', e=>{
        if(e.code==='ArrowUp')    move.forward =  1;
        if(e.code==='ArrowDown')  move.forward = -1;
        if(e.code==='ArrowLeft')  move.turn    =  1;
        if(e.code==='ArrowRight') move.turn    = -1;
      });
      document.addEventListener('keyup', e=>{
        if(e.code==='ArrowUp'||e.code==='ArrowDown')   move.forward=0;
        if(e.code==='ArrowLeft'||e.code==='ArrowRight')move.turn   =0;
      });
      document.addEventListener('mousedown', shoot);
    }

    function shoot(event) {
      mouse.x = (event.clientX/window.innerWidth)*2 - 1;
      mouse.y = -(event.clientY/window.innerHeight)*2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const point = new THREE.Vector3();
      raycaster.ray.intersectPlane(groundPlane, point);

      const b = new THREE.Mesh(
        new THREE.SphereGeometry(0.1,8,8),
        new THREE.MeshBasicMaterial({ color:0xffff00 })
      );
      b.position.copy(player.position).add(new THREE.Vector3(0,1,0));
      const dir = point.clone().sub(b.position).normalize();
      b.userData.velocity = dir.multiplyScalar(50);
      scene.add(b); bullets.push(b);
    }

    // Обновляем патруль охранников
    function updateGuards(dt) {
      guards.forEach(g=>{
        const pt = g.waypoints[g.idx];
        const dir = pt.clone().sub(g.mesh.position);
        const dist = dir.length();
        if(dist < 0.2) {
          g.idx = (g.idx + 1) % g.waypoints.length;
        } else {
          dir.normalize();
          g.mesh.position.addScaledVector(dir, g.speed * dt);
          // Поворачиваем охранника к следующей точке
          g.mesh.lookAt(pt.clone().setY(g.mesh.position.y));
        }
      });
    }

    // Главный цикл
    function animate() {
      requestAnimationFrame(animate);
      const dt = clock.getDelta();

      // Движение игрока
      player.rotation.y += move.turn * turnSpeed * dt;
      const yaw = player.rotation.y;
      const fv = new THREE.Vector3(Math.sin(yaw),0,Math.cos(yaw));
      player.position.addScaledVector(fv, move.forward * speed * dt);

      // Камера за спиной
      const offset = new THREE.Vector3(0,2,5)
        .applyAxisAngle(new THREE.Vector3(0,1,0), yaw);
      camera.position.copy(player.position).add(offset);
      camera.lookAt(player.position.clone().add(new THREE.Vector3(0,1,0)));

      // Пули и попадания
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.position.addScaledVector(b.userData.velocity, dt);
        if (b.position.length() > 200) {
          scene.remove(b); bullets.splice(i,1); continue;
        }
        for (let j = targets.length - 1; j >= 0; j--) {
          const t = targets[j];
          if (b.position.distanceTo(t.position) < 0.6) {
            scene.remove(t); targets.splice(j,1);
            kills++; document.getElementById('kills').textContent = 'Убито: '+kills;
          }
        }
      }

      // Обновляем охранников
      updateGuards(dt);

      renderer.render(scene, camera);
    }

    function onResize() {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth,window.innerHeight);
    }
  </script>
</body>
</html>
