<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>FPS Shooter</title>
<style>
  body { margin:0; overflow:hidden; background:#000; }
  canvas { display:block; }
  #score {
    position:absolute; top:10px; left:10px;
    font-family:sans-serif; font-size:18px; color:white;
    z-index:5;
  }
  #hint {
    position:absolute; bottom:10px; left:50%;
    transform:translateX(-50%);
    font-family:sans-serif; font-size:14px; color:#ccc;
  }
</style>
</head>
<body>
<div id="score">–°—á—ë—Ç: 0</div>
<div id="hint">–ö–ª–∏–∫–Ω–∏—Ç–µ –º—ã—à–∫–æ–π –¥–ª—è –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.156.1/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.156.1/examples/js/controls/PointerLockControls.js"></script>
<script>
// === –°—Ü–µ–Ω–∞, –∫–∞–º–µ—Ä–∞, —Ä–µ–Ω–¥–µ—Ä ===
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(4,1.5,4);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// –°–≤–µ—Ç
const light = new THREE.DirectionalLight(0xffffff,1);
light.position.set(10,20,10);
scene.add(light);
scene.add(new THREE.AmbientLight(0x404040));

// –ü–æ–ª
const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(200,200),
  new THREE.MeshPhongMaterial({color:0x222222})
);
ground.rotation.x = -Math.PI/2;
scene.add(ground);

// === –ö–∞—Ä—Ç–∞ (—Å—Ç–µ–Ω—ã) ===
const map = [
  "####################",
  "#........#.........#",
  "#........#.........#",
  "#........#.........#",
  "#..................#",
  "#........#####.....#",
  "#........#.........#",
  "#........#.........#",
  "####################",
];
const wallSize = 2;
const wallGeometry = new THREE.BoxGeometry(wallSize, wallSize, wallSize);
const wallMaterial = new THREE.MeshPhongMaterial({color:0x5555ff});
for(let z=0; z<map.length; z++){
  for(let x=0; x<map[z].length; x++){
    if(map[z][x]==="#"){
      const wall = new THREE.Mesh(wallGeometry, wallMaterial);
      wall.position.set(x*wallSize, wallSize/2, z*wallSize);
      scene.add(wall);
    }
  }
}

// === –ò–≥—Ä–æ–∫ ===
const controls = new THREE.PointerLockControls(camera, document.body);
document.body.addEventListener("click", ()=>controls.lock());
controls.addEventListener("lock",()=>document.getElementById("hint").style.display="none");
controls.addEventListener("unlock",()=>document.getElementById("hint").style.display="block");

// --- –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ ---
const velocity = new THREE.Vector3();
const direction = new THREE.Vector3();
const keys = {};
document.addEventListener("keydown", e=>keys[e.code]=true);
document.addEventListener("keyup", e=>keys[e.code]=false);

// --- –ü—É–ª–∏ (–ø—Ä–æ–±–µ–ª) ---
let bullets = [];
document.addEventListener("keydown", e=>{
  if(e.code==="Space" && controls.isLocked){
    const geometry = new THREE.SphereGeometry(0.1,8,8);
    const material = new THREE.MeshBasicMaterial({color:0xffff00});
    const bullet = new THREE.Mesh(geometry, material);
    bullet.position.copy(camera.position);
    bullet.userData.velocity = new THREE.Vector3(0,0,-1)
      .applyQuaternion(camera.quaternion)
      .multiplyScalar(0.8);
    scene.add(bullet);
    bullets.push(bullet);
  }
});

// --- –í—Ä–∞–≥–∏ ---
let enemies = [];
let score = 0;
function spawnEnemy(){
  const geometry = new THREE.BoxGeometry(1,1,1);
  const material = new THREE.MeshPhongMaterial({color:0xff0000});
  const enemy = new THREE.Mesh(geometry, material);
  enemy.position.set((Math.random()-0.5)*40,0.5,(Math.random()-0.5)*40);
  scene.add(enemy);
  enemies.push(enemy);
}
setInterval(spawnEnemy,4000);

// === –ê–Ω–∏–º–∞—Ü–∏—è ===
const clock = new THREE.Clock();
function animate(){
  requestAnimationFrame(animate);
  const delta = clock.getDelta();

  // –¥–≤–∏–∂–µ–Ω–∏–µ —Å—Ç—Ä–µ–ª–∫–∞–º–∏
  velocity.x -= velocity.x*10*delta;
  velocity.z -= velocity.z*10*delta;

  direction.set(0,0,0);
  if(keys["ArrowUp"]) direction.z=-1;
  if(keys["ArrowDown"]) direction.z=1;
  if(keys["ArrowLeft"]) direction.x=-1;
  if(keys["ArrowRight"]) direction.x=1;

  direction.normalize();
  const speed = 10;
  if(direction.z!==0) velocity.z -= direction.z*speed*delta;
  if(direction.x!==0) velocity.x -= direction.x*speed*delta;

  controls.moveRight(-velocity.x*delta);
  controls.moveForward(-velocity.z*delta);

  // –ü—É–ª–∏
  bullets.forEach((b,i)=>{
    b.position.add(b.userData.velocity);
    if(b.position.length()>200){
      scene.remove(b);
      bullets.splice(i,1);
    }
  });

  // –í—Ä–∞–≥–∏
  enemies.forEach((enemy,eIndex)=>{
    const dir = camera.position.clone().sub(enemy.position).normalize();
    enemy.position.add(dir.multiplyScalar(0.02));

    bullets.forEach((b,bIndex)=>{
      if(enemy.position.distanceTo(b.position)<1){
        scene.remove(enemy);
        enemies.splice(eIndex,1);
        scene.remove(b);
        bullets.splice(bIndex,1);
        score++;
        document.getElementById("score").innerText = "–°—á—ë—Ç: "+score;
      }
    });

    if(enemy.position.distanceTo(camera.position)<1.5){
      document.getElementById("score").innerText = "üíÄ Game Over!";
      enemies=[];
    }
  });

  renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>
