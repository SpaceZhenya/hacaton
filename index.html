<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>3D Shooter на Three.js</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #crosshair {
      position: absolute;
      top: 50%; left: 50%;
      width: 20px; height: 20px;
      margin: -10px 0 0 -10px;
      pointer-events: none;
      background: url('data:image/svg+xml;utf8,\
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20">\
          <circle cx="10" cy="10" r="2" fill="white"/>\
        </svg>'
      ) no-repeat center;
    }
  </style>
</head>
<body>
  <div id="crosshair"></div>
  <script src="https://unpkg.com/three@0.153.0/build/three.min.js"></script>
  <script>
    // ==== Основные переменные ====
    let scene, camera, renderer;
    let bullets = [], targets = [];
    const clock = new THREE.Clock();

    // ==== Инициализация сцены ====
    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x20232a);

      camera = new THREE.PerspectiveCamera(
        75, window.innerWidth / window.innerHeight, 0.1, 1000
      );
      camera.position.set(0, 1.6, 5);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(5, 10, 7.5);
      scene.add(light);

      const floorGeo = new THREE.PlaneGeometry(200, 200);
      const floorMat = new THREE.MeshStandardMaterial({ color: 0x808080 });
      const floor = new THREE.Mesh(floorGeo, floorMat);
      floor.rotation.x = -Math.PI / 2;
      scene.add(floor);

      createTargets();
      setupControls();
      window.addEventListener('resize', onWindowResize);
      animate();
    }

    // ==== Создание целей ====
    function createTargets() {
      const geo = new THREE.BoxGeometry(1, 1, 1);
      const mat = new THREE.MeshStandardMaterial({ color: 0xff3333 });
      for (let i = 0; i < 20; i++) {
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(
          (Math.random() - 0.5) * 50,
          0.5,
          -Math.random() * 50
        );
        scene.add(mesh);
        targets.push(mesh);
      }
    }

    // ==== Управление игроком и стрельба ====
    const move = { forward: 0, right: 0 };
    const speed = 10;

    function setupControls() {
      document.addEventListener('keydown', e => {
        if (e.code === 'KeyW') move.forward = 1;
        if (e.code === 'KeyS') move.forward = -1;
        if (e.code === 'KeyA') move.right   = -1;
        if (e.code === 'KeyD') move.right   = 1;
      });
      document.addEventListener('keyup', e => {
        if (e.code === 'KeyW' || e.code === 'KeyS') move.forward = 0;
        if (e.code === 'KeyA' || e.code === 'KeyD') move.right   = 0;
      });
      document.addEventListener('mousedown', shoot);
    }

    // ==== Выстрел «пулей» ====
    function shoot() {
      const bulletGeo = new THREE.SphereGeometry(0.1, 8, 8);
      const bulletMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
      const bullet = new THREE.Mesh(bulletGeo, bulletMat);

      bullet.position.copy(camera.position);
      const dir = new THREE.Vector3();
      camera.getWorldDirection(dir);
      bullet.userData = { velocity: dir.multiplyScalar(50) };

      scene.add(bullet);
      bullets.push(bullet);
    }

    // ==== Анимация и физика ====
    function animate() {
      requestAnimationFrame(animate);
      const dt = clock.getDelta();

      // движение игрока
      const forwardVec = new THREE.Vector3();
      camera.getWorldDirection(forwardVec);
      forwardVec.y = 0;
      forwardVec.normalize();

      const rightVec = new THREE.Vector3().crossVectors(
        camera.up, forwardVec
      ).normalize();

      camera.position.addScaledVector(forwardVec, move.forward * speed * dt);
      camera.position.addScaledVector(rightVec, move.right   * speed * dt);

      // обновление пуль
      bullets = bullets.filter(b => {
        b.position.addScaledVector(b.userData.velocity, dt);
        if (b.position.length() > 200) {
          scene.remove(b);
          return false;
        }
        return true;
      });

      // проверка столкновений
      bullets.forEach(b => {
        targets.forEach((t, i) => {
          if (b.position.distanceTo(t.position) < 0.6) {
            scene.remove(t);
            targets.splice(i, 1);
          }
        });
      });

      renderer.render(scene, camera);
    }

    // ==== Подстройка под размер окна ====
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // ==== Запуск ====
    init();
  </script>
</body>
</html>
